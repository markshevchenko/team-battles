\documentclass[a4paper,10pt]{article}
\usepackage[russian]{babel}
\usepackage{fontspec}
\usepackage{nopageno}
\usepackage{svg}
\setmainfont{DejaVu Serif}

\begin{document}

\section*{Алгоритм Хаффмана\\
(задача для синих~--- декодирование)}

Реализовать декодирование текста по алгоритму Хаффмана.

Алгоритм Хаффмана состоит из двух этапов: построение дерева Хаффмана и декодирование.
В этой задаче дерево уже построено, так что вам нужно реализовать только декодирование.

\subsection*{Дерево Хаффмана}

\begin{figure}[htbp]
    \centering
    \includesvg{huffman_abc.svg}
    \caption{Пример дерева Хаффмана}
\end{figure}

Дерево Хаффмана~--- двоичное.
Все его узлы~--- либо \textit{листья}, либо \textit{ветвления}.
Каждому листу сопоставлен один печатный ASCII-символ.
Листья не имеют дочерних узлов.
Ветвления имеют ровно два дочерних узла.

\subsection*{Вход программы}

В первой строке программа получается целое число $N$, $3 \leq N \leq 128$.
Далее следуют $N$ строк такого формата:

\begin{itemize}
    \item Символ \textbf{P} (\textit{англ.} push) за которым записан ровно один печатный символ ASCII. Например, \texttt{Pa}, \texttt{P-}, \texttt{PP}.
    Встретив эту команду, вы должны создать узел типа \textit{лист}.
    Второй символ строки становится значением листа.
    Созданный лист помещается в стек.
    \item Символ \textbf{C} (\textit{англ.} combine).
    Встретив эту команду, вы должны извлечь из стека два узла и создать узел типа \textit{ветвление}.
    Первый извлечённый узел будет правым дочерним узлом, а второй~--- левым.
    Созданное ветвление помещается в стек.
\end{itemize}

После $N$ строк, содержащих команды, следует последняя строка, в которой находится код для декодироваания, сотоящий из цифр \texttt{0} и \texttt{1}.

\noindent\textbf{Пример входа программы}\\
\texttt{ \\
5\\
Pa\\
Pb\\
Pc\\
C\\
C\\
010010110110
}

Эти команды строят дерево, показанное на рисунке.

\subsection*{Декодирование}

Прежде, чем приступить к декодированию, пометим каждую левую ветвь дерева Хаффмана цифрой \texttt{0}, а каждую правую~--- цифрой \texttt{1} (на рисунке это уже сделано, так что вы можете с ним сверяться).

Для перемещения по дереву Хаффмана, нам потребуется указатель, который в самом начале работы должен указывать на корень.

Читаем из входной строки первую цифру, в нашем случае \texttt{0}.
Цифре \texttt{0} соответствует левое поддерево, поэтому перемещаем указатель так, чтобы он указавал на левое поддерево.
Мы добрались до листа \textbf{a}: печатаем символ \textbf{a} и возвращаем указатель обратно на корень дерева.

Читаем из входной строки следующую цифру, это \texttt{1}.
Цифре \texttt{1} соответствует правое поддерево, поэтому перемещаем указатель так, чтобы он указавал на правое поддерево.
Так как текущий узел~--- это ветвление, продолжаем поиск.
Читаем из входной строки следующую цифру, это \texttt{0}.
Цифре \texttt{0} соответствует левое поддерево, поэтому перемещаем указатель так, чтобы он указавал на левое поддерево.
Мы добрались до листа \textbf{b}: печатаем символ \textbf{b} и возвращаем указатель обратно на корень дерева.

Прочитав код \texttt{010010110110}, программа должна напечатать текст \textbf{ababcaca}.
 
\end{document}