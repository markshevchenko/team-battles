\documentclass[a4paper,10pt]{article}
\usepackage[russian]{babel}
\usepackage{fontspec}
\usepackage{nopageno}
\usepackage{svg}
\setmainfont{DejaVu Serif}

\begin{document}

\section*{Алгоритм Хаффмана\\
(задача для красных~--- кодирование)}

Реализовать кодирование текста по алгоритму Хаффмана.

Алгоритм Хаффмана состоит из двух этапов: построение дерева Хаффмана и кодирование.
В этой задаче дерево уже построено, так что вам нужно реализовать только кодирование.

\subsection*{Дерево Хаффмана}

\begin{figure}[htbp]
    \centering
    \includesvg{huffman_abc.svg}
    \caption{Пример дерева Хаффмана}
\end{figure}

Дерево Хаффмана~--- двоичное.
Все его узлы~--- либо \textit{листья}, либо \textit{ветвления}.
Каждому листу сопоставлен один печатный ASCII-символ.
Листья не имеют дочерних узлов.
Ветвления имеют ровно два дочерних узла.

\subsection*{Вход программы}

В первой строке программа получается целое число $N$, $3 \ge N > 128$.
Далее следуют $N$ строк такого формата:

\begin{itemize}
    \item Символ \textbf{P} (\textit{англ.} push) за которым записан ровно один печатный символ ASCII. Например, \texttt{Pa}, \texttt{P-}, \texttt{PP}.
    Встретив эту команду, вы должны создать узел типа \textit{лист}.
    Второй символ строки становится значением листа.
    Созданный лист помещается в стек.
    \item Символ \textbf{C} (\textit{англ.} combine).
    Встретив эту команду, выдолжны извлечь из стека два узла и создать узел типа \textit{ветвление}.
    Первый извлечённый узел будет правым дочерним узлом, а второй~--- левым.
    Созданное ветвление помещается в стек.
\end{itemize}

После $N$ строк, содержащих команды, следует последняя строка, в которой находится текст для кодироваания.

\noindent\textbf{Пример ввода}\\
\texttt{ \\
5\\
Pa\\
Pb\\
Pc\\
C\\
C\\
ababcaca
}

Эти команды строят дерево, показанное на рисунке.

\subsection*{Кодирование}

Мы должны закодировать каждый символ во входной строке.
В нашем примере первый символ это \textbf{a}.

Прежде, чем приступить к кодированию, пометим каждую левую ветвь дерева Хаффмана цифрой \texttt{0}, а каждую правую~--- цифрой \texttt{1} (на рисунке это уже сделано, так что вы можете с ним сверяться).

Составим маршрут от корня дерева до символа \textbf{a}.
Он состоит из одной левой ветви, помеченной цифрой \texttt{0}.
Это значит, что символу \textbf{a} соответствует код \texttt{0}.

Печатаем символ (не бит) \texttt{0}.
Следующий символ~--- \textbf{b}. Маршрут из корня к листу \textbf{b} состоит из правой ветки (помечена цифрой \texttt{1}), сразу за которой следует левая ветка (помечена \texttt{0}).

Таким образом, код символа \textbf{b}~--- это последовательность \texttt{10}, которую мы печатаем без разделителей, то есть без пробелов, запятых, переводов строк и т.д.

Мы закодировали символы \textbf{ab}, напечатав последовательность \texttt{010}.
Далее символы повторяются, поэтому строке \textbf{abab} будет соответствовать код \texttt{010010}.

Затем мы встречаем символ \textbf{c}.
Построив в дереве путь от корня до символа \textbf{c}, мы определим его код~--- \texttt{11}.
Печатаем эти цифры.

После кодирвоания всей строки \textbf{ababcaca}, программа должна напечатать \texttt{010010110110}.

\end{document}